"""
Exploit Scenario Simulation (SIM) for Phase 6.

Heuristic economic modeling for exploit scenarios including capital requirements,
payoff estimation, and feasibility classification.
"""
from __future__ import annotations

import math
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union
from enum import Enum


class FeasibilityLevel(Enum):
    """Feasibility classification for exploit scenarios."""
    PLAUSIBLE = "plausible"
    IMPROBABLE = "improbable"
    UNKNOWN = "unknown"


class ExploitType(Enum):
    """Types of exploit scenarios."""
    REENTRANCY = "reentrancy"
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN = "flash_loan"
    FRONT_RUNNING = "front_running"
    SANDWICH_ATTACK = "sandwich_attack"
    GOVERNANCE_ATTACK = "governance_attack"
    BRIDGE_EXPLOIT = "bridge_exploit"
    LIQUIDATION = "liquidation"
    ARBITRAGE = "arbitrage"
    UNKNOWN = "unknown"


@dataclass
class MarketConditions:
    """Market conditions affecting exploit feasibility."""
    
    volatility: float = 0.1  # Price volatility (0.0-1.0)
    liquidity_depth: float = 1000000.0  # Available liquidity in USD
    gas_price_gwei: float = 20.0
    mev_competition: float = 0.5  # MEV competition level (0.0-1.0)
    slippage_tolerance: float = 0.01  # 1% default
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "volatility": self.volatility,
            "liquidity_depth": self.liquidity_depth,
            "gas_price_gwei": self.gas_price_gwei,
            "mev_competition": self.mev_competition,
            "slippage_tolerance": self.slippage_tolerance
        }


@dataclass
class CapitalRequirements:
    """Capital requirements for executing an exploit."""
    
    minimum_capital_usd: float
    optimal_capital_usd: float
    collateral_requirements: Dict[str, float] = field(default_factory=dict)
    gas_cost_estimate_usd: float = 0.0
    
    # Time constraints
    execution_time_blocks: int = 1
    preparation_time_minutes: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "minimum_capital_usd": self.minimum_capital_usd,
            "optimal_capital_usd": self.optimal_capital_usd,
            "collateral_requirements": self.collateral_requirements,
            "gas_cost_estimate_usd": self.gas_cost_estimate_usd,
            "execution_time_blocks": self.execution_time_blocks,
            "preparation_time_minutes": self.preparation_time_minutes
        }


@dataclass
class PayoffEstimate:
    """Estimated payoff range for an exploit."""
    
    lower_bound_usd: float
    upper_bound_usd: float
    expected_value_usd: float
    confidence: float  # 0.0-1.0
    
    # Risk factors
    detection_probability: float = 0.5
    reversion_probability: float = 0.1  # Probability of being reverted
    competition_factor: float = 0.5  # Reduced returns due to competition
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "lower_bound_usd": self.lower_bound_usd,
            "upper_bound_usd": self.upper_bound_usd,
            "expected_value_usd": self.expected_value_usd,
            "confidence": self.confidence,
            "detection_probability": self.detection_probability,
            "reversion_probability": self.reversion_probability,
            "competition_factor": self.competition_factor
        }


@dataclass
class ExploitScenario:
    """Complete exploit scenario simulation."""
    
    scenario_id: str
    exploit_type: ExploitType
    target_contract: str
    target_function: str
    
    # Economic analysis
    capital_requirements: CapitalRequirements
    payoff_estimate: PayoffEstimate
    market_conditions: MarketConditions
    
    # Feasibility
    feasibility: FeasibilityLevel
    feasibility_score: float  # 0.0-1.0
    
    # Supporting data
    assumptions: List[str] = field(default_factory=list)
    risk_factors: List[str] = field(default_factory=list)
    mitigation_suggestions: List[str] = field(default_factory=list)
    
    # Path context
    execution_path: Optional[List[str]] = None
    invariant_violations: List[str] = field(default_factory=list)
    
    def get_roi(self) -> float:
        """Calculate return on investment."""
        if self.capital_requirements.minimum_capital_usd <= 0:
            return 0.0
        
        net_expected = (
            self.payoff_estimate.expected_value_usd - 
            self.capital_requirements.gas_cost_estimate_usd
        )
        
        return net_expected / self.capital_requirements.minimum_capital_usd
    
    def get_risk_adjusted_return(self) -> float:
        """Calculate risk-adjusted expected return."""
        base_roi = self.get_roi()
        
        # Adjust for detection and reversion risks
        risk_adjustment = (
            (1 - self.payoff_estimate.detection_probability) * 
            (1 - self.payoff_estimate.reversion_probability) *
            (1 - self.payoff_estimate.competition_factor * 0.5)
        )
        
        return base_roi * risk_adjustment
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "scenario_id": self.scenario_id,
            "exploit_type": self.exploit_type.value,
            "target_contract": self.target_contract,
            "target_function": self.target_function,
            "capital_requirements": self.capital_requirements.to_dict(),
            "payoff_estimate": self.payoff_estimate.to_dict(),
            "market_conditions": self.market_conditions.to_dict(),
            "feasibility": self.feasibility.value,
            "feasibility_score": self.feasibility_score,
            "assumptions": self.assumptions,
            "risk_factors": self.risk_factors,
            "mitigation_suggestions": self.mitigation_suggestions,
            "execution_path": self.execution_path,
            "invariant_violations": self.invariant_violations,
            "roi": self.get_roi(),
            "risk_adjusted_return": self.get_risk_adjusted_return()
        }


class HeuristicEconomicAnalyzer:
    """Heuristic analyzer for economic exploit feasibility."""
    
    def __init__(self):
        # Heuristic constants for different exploit types
        self.exploit_constants = {
            ExploitType.FLASH_LOAN: {
                "min_capital_multiplier": 0.0,  # Flash loans require no upfront capital
                "gas_cost_base": 0.01,  # Base gas cost in ETH
                "complexity_factor": 1.2
            },
            ExploitType.REENTRANCY: {
                "min_capital_multiplier": 0.1,
                "gas_cost_base": 0.005,
                "complexity_factor": 1.0
            },
            ExploitType.ORACLE_MANIPULATION: {
                "min_capital_multiplier": 0.3,
                "gas_cost_base": 0.02,
                "complexity_factor": 1.5
            },
            ExploitType.SANDWICH_ATTACK: {
                "min_capital_multiplier": 0.05,
                "gas_cost_base": 0.01,
                "complexity_factor": 0.8
            },
            ExploitType.GOVERNANCE_ATTACK: {
                "min_capital_multiplier": 0.5,
                "gas_cost_base": 0.05,
                "complexity_factor": 2.0
            }
        }
    
    def analyze_capital_requirements(self, finding: Any, exploit_type: ExploitType,
                                   market_conditions: MarketConditions) -> CapitalRequirements:
        """Analyze capital requirements for an exploit scenario."""
        constants = self.exploit_constants.get(exploit_type, {
            "min_capital_multiplier": 0.2,
            "gas_cost_base": 0.01,
            "complexity_factor": 1.0
        })
        
        # Extract value hints from the finding
        value_hints = self._extract_value_hints(finding)
        base_value = value_hints.get("total_value", 100000.0)  # Default $100k
        
        # Calculate minimum capital needed
        min_capital = base_value * constants["min_capital_multiplier"]
        
        # Flash loans can access more capital
        if exploit_type == ExploitType.FLASH_LOAN:
            optimal_capital = base_value * 2.0  # Can borrow 2x the target value
        else:
            optimal_capital = base_value * 0.5
        
        # Gas cost estimation
        eth_price = 3000.0  # Approximate ETH price
        gas_cost_eth = constants["gas_cost_base"] * constants["complexity_factor"]
        gas_cost_usd = gas_cost_eth * eth_price
        
        # Adjust for current gas prices
        gas_price_multiplier = market_conditions.gas_price_gwei / 20.0  # Normalize to 20 gwei
        gas_cost_usd *= gas_price_multiplier
        
        return CapitalRequirements(
            minimum_capital_usd=min_capital,
            optimal_capital_usd=optimal_capital,
            gas_cost_estimate_usd=gas_cost_usd,
            execution_time_blocks=self._estimate_execution_blocks(exploit_type),
            preparation_time_minutes=self._estimate_preparation_time(exploit_type)
        )
    
    def analyze_payoff_estimate(self, finding: Any, exploit_type: ExploitType,
                              capital_requirements: CapitalRequirements,
                              market_conditions: MarketConditions) -> PayoffEstimate:
        """Analyze potential payoff for an exploit scenario."""
        value_hints = self._extract_value_hints(finding)
        base_value = value_hints.get("total_value", 100000.0)
        
        # Base payoff depends on exploit type
        if exploit_type == ExploitType.FLASH_LOAN:
            # Flash loan exploits can drain significant value
            lower_bound = base_value * 0.1
            upper_bound = base_value * 0.8
        elif exploit_type == ExploitType.ORACLE_MANIPULATION:
            # Oracle manipulation can have high impact
            lower_bound = base_value * 0.05
            upper_bound = base_value * 0.4
        elif exploit_type == ExploitType.REENTRANCY:
            # Reentrancy can be partial or complete
            lower_bound = base_value * 0.02
            upper_bound = base_value * 0.6
        elif exploit_type == ExploitType.SANDWICH_ATTACK:
            # Sandwich attacks have smaller but more reliable returns
            lower_bound = base_value * 0.001
            upper_bound = base_value * 0.01
        else:
            # Default estimates
            lower_bound = base_value * 0.01
            upper_bound = base_value * 0.2
        
        # Adjust for market conditions
        volatility_factor = 1.0 + market_conditions.volatility
        lower_bound *= volatility_factor * 0.5
        upper_bound *= volatility_factor
        
        # Calculate expected value
        expected_value = (lower_bound + upper_bound) / 2
        
        # Adjust for market liquidity
        liquidity_factor = min(1.0, market_conditions.liquidity_depth / base_value)
        expected_value *= liquidity_factor
        
        # Risk factors
        detection_prob = self._calculate_detection_probability(exploit_type, finding)
        reversion_prob = self._calculate_reversion_probability(exploit_type)
        competition_factor = market_conditions.mev_competition
        
        return PayoffEstimate(
            lower_bound_usd=max(0, lower_bound),
            upper_bound_usd=upper_bound,
            expected_value_usd=max(0, expected_value),
            confidence=0.6,  # Heuristic confidence
            detection_probability=detection_prob,
            reversion_probability=reversion_prob,
            competition_factor=competition_factor
        )
    
    def classify_feasibility(self, capital_requirements: CapitalRequirements,
                           payoff_estimate: PayoffEstimate,
                           market_conditions: MarketConditions) -> tuple[FeasibilityLevel, float]:
        """Classify exploit feasibility and compute score."""
        # Calculate profit potential
        net_profit = (
            payoff_estimate.expected_value_usd - 
            capital_requirements.gas_cost_estimate_usd
        )
        
        # ROI calculation
        if capital_requirements.minimum_capital_usd > 0:
            roi = net_profit / capital_requirements.minimum_capital_usd
        else:
            roi = net_profit / 1000.0  # Flash loan scenario
        
        # Risk-adjusted ROI
        risk_adjusted_roi = roi * (1 - payoff_estimate.detection_probability) * (1 - payoff_estimate.reversion_probability)
        
        # Feasibility scoring
        if risk_adjusted_roi > 0.5:  # 50%+ risk-adjusted return
            feasibility = FeasibilityLevel.PLAUSIBLE
            score = min(1.0, risk_adjusted_roi / 2.0)
        elif risk_adjusted_roi > 0.1:  # 10%+ risk-adjusted return
            feasibility = FeasibilityLevel.PLAUSIBLE
            score = 0.3 + (risk_adjusted_roi - 0.1) * 0.5
        elif risk_adjusted_roi > -0.5:  # Not too negative
            feasibility = FeasibilityLevel.IMPROBABLE
            score = 0.1 + max(0, risk_adjusted_roi + 0.5) * 0.4
        else:
            feasibility = FeasibilityLevel.IMPROBABLE
            score = 0.05
        
        # Adjust for market conditions
        if market_conditions.liquidity_depth < capital_requirements.minimum_capital_usd:
            score *= 0.5  # Insufficient liquidity
            feasibility = FeasibilityLevel.IMPROBABLE
        
        return feasibility, score
    
    def _extract_value_hints(self, finding: Any) -> Dict[str, float]:
        """Extract value hints from finding context."""
        # Heuristic value extraction based on finding details
        hints = {"total_value": 100000.0}  # Default
        
        # Look for value indicators in code or description
        if hasattr(finding, 'code'):
            code = finding.code.lower()
            
            # Look for token amounts or value transfers
            if 'transfer' in code or 'mint' in code:
                hints["total_value"] = 500000.0  # Higher for token operations
            elif 'balanceof' in code:
                hints["total_value"] = 200000.0
            elif 'allowance' in code:
                hints["total_value"] = 150000.0
            
        # Look for contract type hints
        if hasattr(finding, 'contract_name'):
            contract_name = finding.contract_name.lower()
            if 'vault' in contract_name or 'pool' in contract_name:
                hints["total_value"] = 1000000.0  # Higher for DeFi protocols
            elif 'token' in contract_name:
                hints["total_value"] = 300000.0
        
        return hints
    
    def _estimate_execution_blocks(self, exploit_type: ExploitType) -> int:
        """Estimate execution time in blocks."""
        block_estimates = {
            ExploitType.FLASH_LOAN: 1,
            ExploitType.SANDWICH_ATTACK: 1,
            ExploitType.REENTRANCY: 1,
            ExploitType.ORACLE_MANIPULATION: 2,
            ExploitType.GOVERNANCE_ATTACK: 100,  # Requires voting period
            ExploitType.BRIDGE_EXPLOIT: 5
        }
        return block_estimates.get(exploit_type, 1)
    
    def _estimate_preparation_time(self, exploit_type: ExploitType) -> int:
        """Estimate preparation time in minutes."""
        prep_times = {
            ExploitType.FLASH_LOAN: 30,
            ExploitType.SANDWICH_ATTACK: 0,  # Automated
            ExploitType.REENTRANCY: 60,
            ExploitType.ORACLE_MANIPULATION: 120,
            ExploitType.GOVERNANCE_ATTACK: 7 * 24 * 60,  # 7 days
            ExploitType.BRIDGE_EXPLOIT: 240
        }
        return prep_times.get(exploit_type, 60)
    
    def _calculate_detection_probability(self, exploit_type: ExploitType, finding: Any) -> float:
        """Calculate probability of exploit detection."""
        base_detection = {
            ExploitType.FLASH_LOAN: 0.3,
            ExploitType.SANDWICH_ATTACK: 0.9,  # Highly visible
            ExploitType.REENTRANCY: 0.4,
            ExploitType.ORACLE_MANIPULATION: 0.5,
            ExploitType.GOVERNANCE_ATTACK: 0.8,  # Public voting
            ExploitType.BRIDGE_EXPLOIT: 0.6
        }
        
        detection_prob = base_detection.get(exploit_type, 0.5)
        
        # Adjust based on finding severity (higher severity = more likely to be monitored)
        if hasattr(finding, 'severity'):
            severity_str = str(finding.severity).upper()
            if severity_str in ['CRITICAL', 'HIGH']:
                detection_prob *= 1.2
            elif severity_str == 'LOW':
                detection_prob *= 0.8
        
        return min(1.0, detection_prob)
    
    def _calculate_reversion_probability(self, exploit_type: ExploitType) -> float:
        """Calculate probability of exploit being reverted."""
        reversion_probs = {
            ExploitType.FLASH_LOAN: 0.05,  # Hard to revert once executed
            ExploitType.SANDWICH_ATTACK: 0.02,
            ExploitType.REENTRANCY: 0.1,
            ExploitType.ORACLE_MANIPULATION: 0.15,
            ExploitType.GOVERNANCE_ATTACK: 0.3,  # Can be countered
            ExploitType.BRIDGE_EXPLOIT: 0.2
        }
        return reversion_probs.get(exploit_type, 0.1)


class ExploitScenarioSimulator:
    """Main simulator for exploit scenarios."""
    
    def __init__(self, market_conditions: Optional[MarketConditions] = None):
        self.market_conditions = market_conditions or MarketConditions()
        self.analyzer = HeuristicEconomicAnalyzer()
    
    def simulate_exploit_scenario(self, finding: Any, path_slice: Optional[Any] = None,
                                invariant_violation: Optional[str] = None) -> ExploitScenario:
        """Simulate an exploit scenario for a finding."""
        # Determine exploit type based on finding
        exploit_type = self._classify_exploit_type(finding)
        
        # Analyze economics
        capital_requirements = self.analyzer.analyze_capital_requirements(
            finding, exploit_type, self.market_conditions
        )
        
        payoff_estimate = self.analyzer.analyze_payoff_estimate(
            finding, exploit_type, capital_requirements, self.market_conditions
        )
        
        feasibility, feasibility_score = self.analyzer.classify_feasibility(
            capital_requirements, payoff_estimate, self.market_conditions
        )
        
        # Generate scenario
        scenario_id = f"exploit_{finding.detector}_{int(hash(finding.file + str(finding.line)) % 100000)}"
        
        scenario = ExploitScenario(
            scenario_id=scenario_id,
            exploit_type=exploit_type,
            target_contract=getattr(finding, 'contract_name', 'Unknown'),
            target_function=getattr(finding, 'function_name', 'unknown'),
            capital_requirements=capital_requirements,
            payoff_estimate=payoff_estimate,
            market_conditions=self.market_conditions,
            feasibility=feasibility,
            feasibility_score=feasibility_score
        )
        
        # Add context from path slice
        if path_slice:
            scenario.execution_path = getattr(path_slice, 'node_sequence', [])
        
        # Add invariant violations
        if invariant_violation:
            scenario.invariant_violations.append(invariant_violation)
        
        # Generate assumptions and risk factors
        scenario.assumptions = self._generate_assumptions(exploit_type, finding)
        scenario.risk_factors = self._generate_risk_factors(exploit_type, finding)
        scenario.mitigation_suggestions = self._generate_mitigations(exploit_type, finding)
        
        return scenario
    
    def simulate_top_scenarios(self, findings: List[Any], max_targets: int = 5) -> List[ExploitScenario]:
        """Simulate exploit scenarios for top findings."""
        scenarios = []
        
        # Sort findings by severity/confidence
        sorted_findings = sorted(
            findings,
            key=lambda f: (
                getattr(f.severity, 'score', 5) * 
                getattr(f, 'confidence', 0.5)
            ),
            reverse=True
        )
        
        for finding in sorted_findings[:max_targets]:
            scenario = self.simulate_exploit_scenario(finding)
            scenarios.append(scenario)
        
        return scenarios
    
    def _classify_exploit_type(self, finding: Any) -> ExploitType:
        """Classify exploit type based on finding characteristics."""
        detector = finding.detector.lower()
        code = getattr(finding, 'code', '').lower()
        category = getattr(finding, 'category', '').lower()
        
        # Pattern matching for exploit types
        if 'reentrancy' in detector or 'reentrancy' in category:
            return ExploitType.REENTRANCY
        elif 'oracle' in detector or 'price' in detector:
            return ExploitType.ORACLE_MANIPULATION
        elif 'flash' in detector or 'loan' in detector:
            return ExploitType.FLASH_LOAN
        elif 'front' in detector or 'mev' in detector:
            return ExploitType.FRONT_RUNNING
        elif 'sandwich' in detector:
            return ExploitType.SANDWICH_ATTACK
        elif 'governance' in detector or 'voting' in detector:
            return ExploitType.GOVERNANCE_ATTACK
        elif 'bridge' in detector or 'cross' in detector:
            return ExploitType.BRIDGE_EXPLOIT
        elif 'liquidat' in detector:
            return ExploitType.LIQUIDATION
        elif 'arbitrage' in detector:
            return ExploitType.ARBITRAGE
        else:
            return ExploitType.UNKNOWN
    
    def _generate_assumptions(self, exploit_type: ExploitType, finding: Any) -> List[str]:
        """Generate assumptions for the exploit scenario."""
        assumptions = [
            "Current market conditions remain stable during execution",
            "No additional security measures are implemented",
            "Sufficient network liquidity exists for the exploit"
        ]
        
        if exploit_type == ExploitType.FLASH_LOAN:
            assumptions.extend([
                "Flash loan providers have sufficient liquidity",
                "No additional flash loan fees are introduced"
            ])
        elif exploit_type == ExploitType.ORACLE_MANIPULATION:
            assumptions.extend([
                "Oracle update frequency remains predictable",
                "Sufficient capital exists to manipulate price feeds"
            ])
        elif exploit_type == ExploitType.GOVERNANCE_ATTACK:
            assumptions.extend([
                "Sufficient governance tokens can be acquired",
                "Voting period allows for attack execution"
            ])
        
        return assumptions
    
    def _generate_risk_factors(self, exploit_type: ExploitType, finding: Any) -> List[str]:
        """Generate risk factors for the exploit scenario."""
        risks = [
            "Transaction may fail due to state changes",
            "High gas costs during network congestion",
            "Potential detection by monitoring systems"
        ]
        
        if exploit_type == ExploitType.FLASH_LOAN:
            risks.extend([
                "Flash loan may be reverted due to failed conditions",
                "Competition from other MEV bots"
            ])
        elif exploit_type == ExploitType.ORACLE_MANIPULATION:
            risks.extend([
                "Oracle prices may update faster than expected",
                "Circuit breakers may halt trading"
            ])
        
        return risks
    
    def _generate_mitigations(self, exploit_type: ExploitType, finding: Any) -> List[str]:
        """Generate mitigation suggestions."""
        mitigations = [
            "Implement reentrancy guards where appropriate",
            "Add proper access controls and validation",
            "Consider using commit-reveal schemes for sensitive operations"
        ]
        
        if exploit_type == ExploitType.FLASH_LOAN:
            mitigations.extend([
                "Implement flash loan detection and protection",
                "Add time delays for large transactions"
            ])
        elif exploit_type == ExploitType.ORACLE_MANIPULATION:
            mitigations.extend([
                "Use multiple oracle sources with consensus",
                "Implement TWAP (Time-Weighted Average Price) mechanisms"
            ])
        
        return mitigations